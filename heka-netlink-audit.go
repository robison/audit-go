package netlinkaudit

import (
  "code.google.com/p/go-uuid/uuid"
	"encoding/json"
	"fmt"
	"github.com/mozilla-services/heka/message"
	. "github.com/mozilla-services/heka/pipeline"
	"github.com/robison/audit-go/netlinkAudit"
	"io/ioutil"
	"net"
	"net/http"
	"log"
	"os"
	"syscall"
	"time"
)

var done chan bool
var debug bool

type NetlinkAuditInput struct {
	conf     *NetlinkAuditInputConfig
	stopChan chan bool
	ir       InputRunner
	pConfig  *pipeline.PipelineConfig
}

// NetlinkAuditInput config struct
type NetlinkAuditInputConfig struct {
	// Specifies whether or not notification data should be written to outgoing
	// message payloads, in JSON format as generated by Amazon SNS. If false data
	// will be written to outgoing message fields.
	// Defaults to true.
	EmitInPayload bool `toml:"emit_in_payload"`
	DecoderName string `toml:"decoder"`
}

/*
	err = netlinkAudit.AuditSetRateLimit(s, 600)
	if err != nil {
		log.Fatalln("Error Setting Rate Limit!!", err)
	}
	err = netlinkAudit.AuditSetBacklogLimit(s, 420)
	if err != nil {
		log.Fatalln("Error Setting Backlog Limit!!", err)
	}
	err = netlinkAudit.AuditSetPid(s, uint32(syscall.Getpid()))
	if err == nil {
		log.Println("Set pid successful!!")
	}

	if err != nil {
		return fmt.Errorf("[NetlinkAuditInput] Could not listen on NETLINK_AUDIT socket: %s\n", err.Error())
	}

*/

// Default configuration for NetlinkAudit Input
func (nla *NetlinkAuditInput) ConfigStruct() interface{} {
	return &NetlinkAuditInputConfig{
		EmitInPayload:    true,
	}
}

func (nla *NetlinkAuditInput) SetPipelineConfig(pConfig *pipeline.PipelineConfig) {
	nla.pConfig = pConfig
}

func (nla *NetlinkAuditInput) Init(config interface{}) (err error) {
	nla.stopChan = make(chan bool, 1)
	nla.conf = config.(*NetlinkAuditInputConfig)
	if conf.DecoderName != "" {
		decoder, ok = input.pConfig.Decoder(conf.DecoderName)
	}
	if ok && decoder != nil {
		// We want to know what kind of decoder is being used, but we only
		// care if they're using a protobuf decoder, or a multidecoder with
		// a protobuf decoder as the first sub decoder
		switch decoder.(type) {
		case *pipeline.ProtobufDecoder:
			useMsgBytes = true
		case *pipeline.MultiDecoder:
			d := decoder.(*pipeline.MultiDecoder)
			if len(d.Decoders) > 0 {
				if _, ok := d.Decoders[0].(*pipeline.ProtobufDecoder); ok {
					useMsgBytes = true
				}
			}
		}
	}
	return nil
}

func (nla *NetlinkAuditInput) Run(ir pipeline.InputRunner, pih pipeline.PluginHelper) (err error) {
	var (
		dRunner pipeline.DecoderRunner
		pack    *pipeline.PipelinePack
		ok      bool
	)

	if nla.DecoderName != "" {
	if dRunner, ok = helper.DecoderRunner(nla.DecoderName,
		fmt.Sprintf("%s-%s", runner.Name(), nla.DecoderName)); !ok {
		return fmt.Errorf("Decoder not found: %s", nla.DecoderName)
	}
		nla.decoderChan = dRunner.InChan()
	}

	nla.ir = ir
	nla.pConfig = pih.PipelineConfig()

	packSupply := runner.InChan()
	nla.Conn.Subscribe(nla.Subject, func(msg *nats.Msg) {
		pack = <-packSupply
		if *nla.UseMsgBytes {
			pack.MsgBytes = msg.Data
		} else {
			pack.Message.SetUuid(uuid.NewRandom())
			pack.Message.SetTimestamp(time.Now().UnixNano())
			pack.Message.SetType("audit_message")
			pack.Message.SetHostname(hostname)
			pack.Message.SetPayload(string(msg.Data))
		}
		nla.sendPack(pack)
	})

	<-nla.stopChan
	return nil
}

func (nla *NetlinkAuditInput) Stop() {
	nla.Close()
	close(nla.stopChan)
}


func init() {
	RegisterPlugin("NetlinkAuditInput", func() interface{} {
		return new(NetlinkAuditInput)
	})
}
